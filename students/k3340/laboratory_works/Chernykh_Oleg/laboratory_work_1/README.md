# Лабораторная работа №1

## Задание 1: UDP клиент-сервер

### Техническое задание

Реализовать клиентскую и серверную часть приложения. Клиент отправляет серверу сообщение «Hello, server», и оно должно отобразиться на стороне сервера. В ответ сервер отправляет клиенту сообщение «Hello, client», которое должно отобразиться у клиента.

### Требования

- Обязательно использовать библиотеку `socket`
- Реализовать с помощью протокола UDP

### Реализация

**Файлы:**
- `task_1/udp_server.py` — серверная часть
- `task_1/udp_client.py` — клиентская часть

**Описание:**

Сервер создаёт UDP сокет, привязывает его к адресу `127.0.0.1:9999` и ожидает входящих сообщений. При получении сообщения от клиента сервер выводит его на экран и отправляет ответное сообщение «Hello, client».

Клиент создаёт UDP сокет, отправляет сообщение «Hello, server» на сервер и ожидает ответ. Полученное сообщение выводится на экран.

### Запуск

1. Запустите сервер:
```bash
cd task_1
python udp_server.py
```

2. В другом терминале запустите клиент:
```bash
cd task_1
python udp_client.py
```

## Задание 2: TCP клиент-сервер с математической операцией

### Техническое задание

Реализовать клиентскую и серверную часть приложения. Клиент запрашивает выполнение математической операции, параметры которой вводятся с клавиатуры. Сервер обрабатывает данные и возвращает результат клиенту.

**Вариант операции:** Теорема Пифагора (вычисление гипотенузы по двум катетам).

### Требования

- Обязательно использовать библиотеку `socket`
- Реализовать с помощью протокола TCP

### Реализация

**Файлы:**
- `task_2/tcp_server.py` — серверная часть
- `task_2/tcp_client.py` — клиентская часть

**Описание:**

Сервер создаёт TCP сокет, привязывает его к адресу `127.0.0.1:9999` и ожидает подключений. При подключении клиента сервер принимает два числа (катеты `a` и `b`), вычисляет гипотенузу по формуле `c = √(a² + b²)` с помощью функции `math.hypot()` и отправляет результат клиенту.

Клиент запрашивает у пользователя ввод двух катетов, проверяет корректность ввода, подключается к серверу, отправляет данные и выводит полученный результат.

### Запуск

1. Запустите сервер:
```bash
cd task_2
python tcp_server.py
```

2. В другом терминале запустите клиент:
```bash
cd task_2
python tcp_client.py
```

3. Введите значения катетов при запросе:
```
Enter leg a: 3
Enter leg b: 4
```


## Задание 3: HTTP сервер с загрузкой HTML

### Техническое задание

Реализовать серверную часть приложения. Клиент подключается к серверу, и в ответ получает HTTP-сообщение, содержащее HTML-страницу, которая сервер подгружает из файла `index.html`.

### Требования

- Обязательно использовать библиотеку `socket`

### Реализация

**Файлы:**
- `task_3/http_server.py` — серверная часть
- `task_3/index.html` — HTML-страница

**Описание:**

Сервер создаёт TCP сокет и привязывает его к адресу `127.0.0.1:8080`. При подключении клиента сервер:
1. Принимает HTTP-запрос
2. Читает файл `index.html` из той же директории
3. Формирует HTTP-ответ с заголовками
4. Отправляет заголовки и содержимое HTML-файла клиенту

Если файл `index.html` не найден, сервер возвращает ответ `404 Not Found`.

HTML-страница содержит дизайн с градиентным фоном и информацией о работе сервера.

### Запуск

1. Запустите сервер:
```bash
cd task_3
python http_server.py
```

2. Откройте браузер и перейдите по адресу:
```
http://127.0.0.1:8080
```

## Задание 4: Многопользовательский чат

### Техническое задание

Реализовать многопользовательский чат.

### Требования

- Обязательно использовать библиотеку `socket`
- Для многопользовательского чата необходимо использовать библиотеку `threading`
- Протокол TCP
- Чат должен быть многопользовательским (больше двух человек)
- Для запуска каждого клиента должен использоваться 1 файл (можно запускать `client.py` несколько раз для подключения нескольких пользователей)

### Реализация

**Файлы:**
- `task_4/server.py` — серверная часть
- `task_4/client.py` — клиентская часть

**Описание:**

**Сервер:**
- Создаёт TCP сокет и привязывает его к адресу `127.0.0.1:10000`
- Поддерживает до 10 одновременных подключений
- Для каждого подключения создаётся отдельный поток (`threading.Thread`)
- Использует список `clients` для хранения всех подключённых клиентов
- Использует `threading.Lock` для безопасного доступа к списку клиентов
- Функция `broadcast()` отправляет сообщение всем клиентам, кроме отправителя
- При подключении клиента отправляется приветственное сообщение и уведомление остальным пользователям
- При отключении клиента отправляется уведомление остальным пользователям

**Клиент:**
- Подключается к серверу по адресу `127.0.0.1:10000`
- Использует два потока:
  - `receive_loop()` — принимает и выводит сообщения от сервера
  - `send_loop()` — читает ввод пользователя и отправляет сообщения на сервер
- При вводе пустой строки клиент отключается

### Запуск

1. Запустите сервер:
```bash
cd task_4
python server.py
```

2. В нескольких терминалах запустите клиентов (можно запустить 3 и более экземпляров):
```bash
cd task_4
python client.py
```

3. В каждом клиенте вводите сообщения и нажимайте Enter для отправки. Для выхода введите пустую строку.

## Задание 5: Веб-сервер для журнала оценок

### Техническое задание

Написать простой веб-сервер для обработки GET и POST HTTP-запросов с помощью библиотеки `socket` в Python.

**Требования:**
- Сервер должен принять и записать информацию о дисциплине и оценке по дисциплине
- Отдать информацию обо всех оценках по дисциплинам в виде HTML-страницы
- Вы создаёте журнал. Это значит, что как минимум необходимо структурировано хранить оценки по каждому добавленному предмету (условно добавив 2 оценки к дисциплине "Математика" вы должны в результате получить одну строчку с предметом со списком из двух оценок)

### Реализация

**Файлы:**
- `task_5/server.py` — серверная часть

**Описание:**

Сервер реализует простой веб-сервер с поддержкой GET и POST запросов:

1. **Хранение данных:**
   - Использует словарь `journal: dict[str, list[str]]` для хранения оценок
   - Ключ — название дисциплины, значение — список оценок

2. **Обработка запросов:**
   - **GET `/`** — отображает HTML-страницу с таблицей всех дисциплин и оценок, а также форму для добавления новой записи
   - **POST `/add`** — принимает данные формы (дисциплина и оценка), добавляет оценку к соответствующей дисциплине и перенаправляет на главную страницу (HTTP 303 See Other)

3. **Парсинг HTTP:**
   - Парсит HTTP-заголовки и тело запроса
   - Декодирует URL-encoded данные формы

4. **Генерация HTML:**
   - Динамически генерирует HTML-страницу с таблицей оценок
   - Сортирует дисциплины по алфавиту
   - Отображает оценки через запятую для каждой дисциплины
   - Включает форму для добавления новых записей

5. **HTTP-ответы:**
   - `200 OK` — для успешного отображения страницы
   - `303 See Other` — для редиректа после добавления записи

### Запуск

1. Запустите сервер:
```bash
cd task_5
python server.py
```

2. Откройте браузер и перейдите по адресу:
```
http://127.0.0.1:8081
```

3. Используйте форму на странице для добавления дисциплин и оценок:
   - Введите название дисциплины (например, "Математика")
   - Введите оценку (например, "5")
   - Нажмите кнопку "Добавить"

4. Повторите шаг 3 для добавления нескольких оценок к одной дисциплине или для добавления разных дисциплин.

## Заключение

В ходе выполнения лабораторной работы были реализованы различные аспекты сетевого программирования на Python:

1. **UDP-коммуникация** — изучена работа с ненадёжным протоколом без установления соединения
2. **TCP-коммуникация** — реализована надёжная передача данных с установлением соединения
3. **HTTP-сервер** — создан простой веб-сервер с поддержкой HTTP-протокола и загрузкой статических файлов
4. **Многопоточность** — применена для создания многопользовательского чата с одновременной обработкой нескольких клиентов
5. **Веб-приложение** — реализован полноценный веб-сервер с обработкой GET и POST запросов, хранением данных и динамической генерацией HTML
